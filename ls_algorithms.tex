\documentclass[10pt]{article}
\usepackage[left=2.54cm,top=2.54cm,right=2.54cm,bottom=2.54cm]{geometry}
\usepackage{afterpage}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bm}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage[inline]{enumitem}
\usepackage{setspace}
\usepackage{url}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{xcolor}
\begin{document}
General conservation laws that govern physical systems written in 
PDE form as 
\begin{equation}
q_t + \nabla . (F(q)) = 0
\end{equation}
when discretized in space and time and cast in iterative form almost
always result in sparse linear system of form:
\begin{equation}
  A \Delta q = B
\end{equation}
that needs to be solved iterative in every non-linear cycle of solution
scheme. One of the techniques to iteratively solve the system is to use a
Gauss-Seidel preconditioner. One multi-threaded systems, one will
have to create a color order to create a parallel iterative
technique. Coloring involves grouping the variables in $\Delta q$, such that
for every row, the group associated with the degree of freedom
corresponding to an off-diagonal entry is different from
group associated with the diagonal degree of freedom.
Once, coloring has been established, the system above can be
represented as
\begin{equation}
  (L+D+U) \Delta q = B
\end{equation}
where $L$ corresponds to off-diagonal elements of a smaller color
compared to that of the diagonal entry, $D$ is the diagonal entry
and $U$ corresponds to off-diagonal elements of a larger color.
Given these, the Gauss-Seidel algorithm can be written as follows, 
where one loops forward and backward in colors
\begin{algorithm}
  \caption{Colored Gauss Seidel Algorithm}
  \begin{algorithmic}[1]
  \For{$i = 0, \dots, niter$} %\comment {Iteration loop}
      \State o=0
      \If {$i > 0$}
        \State o=1
      \EndIf
      \For{$color=1+o, \dots, ncolors$}
        \For{$k \in colorgoup(color)$}
         \State $\Delta q_k = {D_k}^{-1}(B_k-L_{kj}\Delta q_{color(j) < color}-U_{kj}\Delta q_{color(j) >color})$
        \EndFor
      \EndFor
      \For{$color=ncolors-1, \dots, 1$ }
       \For{$k \in colorgoup(color)$}
         \State $\Delta q_k = {D_k}^{-1}(B_k-L_{kj}\Delta q_{color(j) < color}-U_{kj}\Delta q_{color(j) > color})$
       \EndFor
      \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}
Lines 7 and 10 of the algorithm above are fully parallel loops can be fully multi-threaded
on a gpu for each $k$. All of $L_{kj}$, $D_k$ and $U_{kj}$, $j \in non-zero\hspace{0.05in}entries\hspace{0.05in}in
\hspace{0.05in}row_k\hspace{0.05in}of\hspace{0.05in}A$ are block matrices of 
size $nq\times nq$, where $nq=5$ for laminar Navier-Stokes equations. To improve the fetch patterns, 
we can do a few things.
\begin{enumerate}
  \item Precondition each row with $D_k^{-1}$ to begin with and store 
        $D_k^{-1}L_{kj}$ and $D_k^{-1}U_{kj}$
  \item Store products $L_{kj}\Delta q_{c < color}$ and $U_{kj}\Delta q_{c>color}$ in a 
        intermediate variables in the forward sweep and backward sweep, 
        so that they can be reused in reverse order, i.e. in the backward sweep and
        forward sweep respectively. This will require only fetching $L$ in the forward
        loop and only $U$ in the backward loop
\end{enumerate}
With these modifications, the "Low-fetch Colored Gauss-Seidel" algorithm can be formulated as
\begin{algorithm}
  \caption{Low-fetch Colored Gauss Seidel Algorithm}
  \begin{algorithmic}[1]
  \State Adq=0
  \State $L_{kj}=D_k^{-1}L_{kj}$
  \State $U_{kj}=D_k^{-1}U_{kj}$
  \State $B_k = D_k^{-1}B_k$
  \For{$i = 0, \dots, niter$} %\comment {Iteration loop}
      \State o=0
      \If {$i > 0$}
        \State o=1
      \EndIf
      \For{$color=1+o, \dots, ncolors$}
        \For{$k \in colorgoup(color)$}
         \State $\Delta q_k = (B_k-L_{kj}\Delta q_{color(j) < color}-Adq_k)$
         \State $Adq_k = L\Delta q_{color(j) < color}$
        \EndFor
      \EndFor
      \For{$k \in colorgoup(1)$}
        \State $Adq_k=0$
      \EndFor
      \For{$color=ncolors-1, \dots, 1$ }
        \For{$k \in colorgoup(color)$}
        \State $\Delta q_k = (B_k-U_{kj}\Delta q_{color(j) >color}-Adq_k)$
        \State $Adq_k = U_{kj}\Delta q_{color(j) < color}$
        \EndFor
      \EndFor
      \For{$k \in colorgoup(ncolor)$}
        \State $Adq_k=0$
      \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}
The implementations of this algorithm, the baseline algorithm as well as a
sequential GS algorithm in MATLAB/OCTAVE are included in this folder. It can
be observed that both the baseline and new algorithm give identical results
in terms of solution convergence and residuals. Implementations on GPUs can
follow this general framework. 
\end{document}
  


